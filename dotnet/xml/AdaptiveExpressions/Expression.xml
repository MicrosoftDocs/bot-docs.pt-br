<Type Name="Expression" FullName="AdaptiveExpressions.Expression">
  <Metadata><Meta Name="ms.openlocfilehash" Value="631b7cbcc6f0753ba6feb46fa06377d85a841ddf" /><Meta Name="ms.sourcegitcommit" Value="71e7c93a312c21f0559005656e7b237e5a74113c" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="11/23/2020" /><Meta Name="ms.locfileid" Value="95463540" /></Metadata><TypeSignature Language="C#" Value="public class Expression" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Expression extends System.Object" />
  <TypeSignature Language="DocId" Value="T:AdaptiveExpressions.Expression" />
  <TypeSignature Language="VB.NET" Value="Public Class Expression" />
  <TypeSignature Language="F#" Value="type Expression = class" />
  <AssemblyInfo>
    <AssemblyName>AdaptiveExpressions</AssemblyName>
    <AssemblyVersion>4.9.3.0</AssemblyVersion>
    <AssemblyVersion>4.10.0.0</AssemblyVersion>
    <AssemblyVersion>4.10.3.0</AssemblyVersion>
    <AssemblyVersion>4.11.0.0</AssemblyVersion>
    <AssemblyVersion>4.11.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[Newtonsoft.Json.JsonConverter(typeof(AdaptiveExpressions.Converters.ExpressionConverter))]</AttributeName>
      <AttributeName Language="F#">[&lt;Newtonsoft.Json.JsonConverter(typeof(AdaptiveExpressions.Converters.ExpressionConverter))&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Uma expressão que pode ser analisada ou avaliada para produzir um valor.</summary>
    <remarks>Isso fornece um wrapper aberto que dá suporte a várias funções internas e também pode ser estendido em tempo de execução.
Ele também dá suporte à validação da exatidão de uma expressão e avaliação que devem ser gratuitas de exceção.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Expression (AdaptiveExpressions.ExpressionEvaluator evaluator, params AdaptiveExpressions.Expression[] children);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class AdaptiveExpressions.ExpressionEvaluator evaluator, class AdaptiveExpressions.Expression[] children) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.#ctor(AdaptiveExpressions.ExpressionEvaluator,AdaptiveExpressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (evaluator As ExpressionEvaluator, ParamArray children As Expression())" />
      <MemberSignature Language="F#" Value="new AdaptiveExpressions.Expression : AdaptiveExpressions.ExpressionEvaluator * AdaptiveExpressions.Expression[] -&gt; AdaptiveExpressions.Expression" Usage="new AdaptiveExpressions.Expression (evaluator, children)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="evaluator" Type="AdaptiveExpressions.ExpressionEvaluator" />
        <Parameter Name="children" Type="AdaptiveExpressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="evaluator">Informações sobre como validar e avaliar a expressão.</param>
        <param name="children">Expressões filhas.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:AdaptiveExpressions.Expression" />.
Construtor de expressão.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Expression (string type, params AdaptiveExpressions.Expression[] children);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string type, class AdaptiveExpressions.Expression[] children) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.#ctor(System.String,AdaptiveExpressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (type As String, ParamArray children As Expression())" />
      <MemberSignature Language="F#" Value="new AdaptiveExpressions.Expression : string * AdaptiveExpressions.Expression[] -&gt; AdaptiveExpressions.Expression" Usage="new AdaptiveExpressions.Expression (type, children)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="type" Type="System.String" />
        <Parameter Name="children" Type="AdaptiveExpressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Tipo de expressão interna de <see cref="T:AdaptiveExpressions.ExpressionType" /> .</param>
        <param name="children">Expressões filhas.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:AdaptiveExpressions.Expression" />.
Construtor de expressão interna.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Accessor">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression Accessor (string property, AdaptiveExpressions.Expression instance = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression Accessor(string property, class AdaptiveExpressions.Expression instance) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.Accessor(System.String,AdaptiveExpressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Accessor (property As String, Optional instance As Expression = Nothing) As Expression" />
      <MemberSignature Language="F#" Value="static member Accessor : string * AdaptiveExpressions.Expression -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.Accessor (property, instance)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="System.String" />
        <Parameter Name="instance" Type="AdaptiveExpressions.Expression" />
      </Parameters>
      <Docs>
        <param name="property">Propriedade a ser pesquisada.</param>
        <param name="instance">Expressão para obter a instância que contém a propriedade ou NULL para o estado global.</param>
        <summary>Construa e valide um acessador de propriedade.</summary>
        <returns>Nova expressão.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AndExpression">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression AndExpression (params AdaptiveExpressions.Expression[] children);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression AndExpression(class AdaptiveExpressions.Expression[] children) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.AndExpression(AdaptiveExpressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AndExpression (ParamArray children As Expression()) As Expression" />
      <MemberSignature Language="F#" Value="static member AndExpression : AdaptiveExpressions.Expression[] -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.AndExpression children" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="children" Type="AdaptiveExpressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="children">Cláusulas filho.</param>
        <summary>Construa e valide uma expressão and.</summary>
        <returns>Nova expressão.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public AdaptiveExpressions.Expression[] Children { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class AdaptiveExpressions.Expression[] Children" />
      <MemberSignature Language="DocId" Value="P:AdaptiveExpressions.Expression.Children" />
      <MemberSignature Language="VB.NET" Value="Public Property Children As Expression()" />
      <MemberSignature Language="F#" Value="member this.Children : AdaptiveExpressions.Expression[] with get, set" Usage="AdaptiveExpressions.Expression.Children" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define as expressões filhas.</summary>
        <value>Expressões filhas.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstantExpression">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression ConstantExpression (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression ConstantExpression(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.ConstantExpression(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConstantExpression (value As Object) As Expression" />
      <MemberSignature Language="F#" Value="static member ConstantExpression : obj -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.ConstantExpression value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Valor constante.</param>
        <summary>Construa uma expressão constante.</summary>
        <returns>Nova expressão.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeepEquals">
      <MemberSignature Language="C#" Value="public virtual bool DeepEquals (AdaptiveExpressions.Expression other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool DeepEquals(class AdaptiveExpressions.Expression other) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.DeepEquals(AdaptiveExpressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeepEquals (other As Expression) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member DeepEquals : AdaptiveExpressions.Expression -&gt; bool&#xA;override this.DeepEquals : AdaptiveExpressions.Expression -&gt; bool" Usage="expression.DeepEquals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="AdaptiveExpressions.Expression" />
      </Parameters>
      <Docs>
        <param name="other">Outra expressão.</param>
        <summary>Faça uma igualdade profunda entre expressões.</summary>
        <returns>True se as expressões forem iguais.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EqualsExpression">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression EqualsExpression (params AdaptiveExpressions.Expression[] children);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression EqualsExpression(class AdaptiveExpressions.Expression[] children) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.EqualsExpression(AdaptiveExpressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EqualsExpression (ParamArray children As Expression()) As Expression" />
      <MemberSignature Language="F#" Value="static member EqualsExpression : AdaptiveExpressions.Expression[] -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.EqualsExpression children" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="children" Type="AdaptiveExpressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="children">Cláusulas filho.</param>
        <summary>Construa e valide uma expressão Equals.</summary>
        <returns>Nova expressão.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Evaluator">
      <MemberSignature Language="C#" Value="public AdaptiveExpressions.ExpressionEvaluator Evaluator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class AdaptiveExpressions.ExpressionEvaluator Evaluator" />
      <MemberSignature Language="DocId" Value="P:AdaptiveExpressions.Expression.Evaluator" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evaluator As ExpressionEvaluator" />
      <MemberSignature Language="F#" Value="member this.Evaluator : AdaptiveExpressions.ExpressionEvaluator" Usage="AdaptiveExpressions.Expression.Evaluator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.ExpressionEvaluator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém avaliador de expressão.</summary>
        <value>avaliador de expressão.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Functions">
      <MemberSignature Language="C#" Value="public static readonly AdaptiveExpressions.Expression.FunctionTable Functions;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class AdaptiveExpressions.Expression/FunctionTable Functions" />
      <MemberSignature Language="DocId" Value="F:AdaptiveExpressions.Expression.Functions" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Functions As Expression.FunctionTable " />
      <MemberSignature Language="F#" Value=" staticval mutable Functions : AdaptiveExpressions.Expression.FunctionTable" Usage="AdaptiveExpressions.Expression.Functions" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression+FunctionTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Dicionário de Function = &gt; ExpressionEvaluator.</summary>
        <remarks>Essas são todas as funções disponíveis, você pode adicionar funções personalizadas a ela, mas não pode substituir funções internas.  Se você limpar o dicionário, ele será redefinido para as funções internas.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LambaExpression">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression LambaExpression (AdaptiveExpressions.EvaluateExpressionDelegate function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression LambaExpression(class AdaptiveExpressions.EvaluateExpressionDelegate function) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.LambaExpression(AdaptiveExpressions.EvaluateExpressionDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LambaExpression (function As EvaluateExpressionDelegate) As Expression" />
      <MemberSignature Language="F#" Value="static member LambaExpression : AdaptiveExpressions.EvaluateExpressionDelegate -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.LambaExpression function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="AdaptiveExpressions.EvaluateExpressionDelegate" />
      </Parameters>
      <Docs>
        <param name="function">Função da qual criar uma expressão.</param>
        <summary>Construa uma expressão a partir de um <see cref="T:AdaptiveExpressions.EvaluateExpressionDelegate" /> .</summary>
        <returns>Nova expressão.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lambda">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression Lambda (Func&lt;object,object&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression Lambda(class System.Func`2&lt;object, object&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.Lambda(System.Func{System.Object,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lambda (function As Func(Of Object, Object)) As Expression" />
      <MemberSignature Language="F#" Value="static member Lambda : Func&lt;obj, obj&gt; -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.Lambda function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,System.Object&gt;" />
      </Parameters>
      <Docs>
        <param name="function">Expressão lambda a ser avaliada.</param>
        <summary>Construa uma expressão a partir de uma expressão lambda sobre o estado.</summary>
        <returns>Nova expressão.</returns>
        <remarks>As exceções serão capturadas e exibidas na superfície como uma cadeia de caracteres de erro.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Lookup">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.ExpressionEvaluator Lookup (string functionName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.ExpressionEvaluator Lookup(string functionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.Lookup(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Lookup (functionName As String) As ExpressionEvaluator" />
      <MemberSignature Language="F#" Value="static member Lookup : string -&gt; AdaptiveExpressions.ExpressionEvaluator" Usage="AdaptiveExpressions.Expression.Lookup functionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.ExpressionEvaluator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="functionName">nome da função.</param>
        <summary>Pesquisa um ExpressionEvaluator (função) por nome.</summary>
        <returns>ExpressionEvaluator.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeExpression">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression MakeExpression (AdaptiveExpressions.ExpressionEvaluator evaluator, params AdaptiveExpressions.Expression[] children);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression MakeExpression(class AdaptiveExpressions.ExpressionEvaluator evaluator, class AdaptiveExpressions.Expression[] children) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.MakeExpression(AdaptiveExpressions.ExpressionEvaluator,AdaptiveExpressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeExpression (evaluator As ExpressionEvaluator, ParamArray children As Expression()) As Expression" />
      <MemberSignature Language="F#" Value="static member MakeExpression : AdaptiveExpressions.ExpressionEvaluator * AdaptiveExpressions.Expression[] -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.MakeExpression (evaluator, children)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evaluator" Type="AdaptiveExpressions.ExpressionEvaluator" />
        <Parameter Name="children" Type="AdaptiveExpressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="evaluator">Informações sobre como validar e avaliar a expressão.</param>
        <param name="children">Expressões filhas.</param>
        <summary>Crie uma expressão e valide-a.</summary>
        <returns>Nova expressão.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeExpression">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression MakeExpression (string type, params AdaptiveExpressions.Expression[] children);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression MakeExpression(string type, class AdaptiveExpressions.Expression[] children) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.MakeExpression(System.String,AdaptiveExpressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeExpression (type As String, ParamArray children As Expression()) As Expression" />
      <MemberSignature Language="F#" Value="static member MakeExpression : string * AdaptiveExpressions.Expression[] -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.MakeExpression (type, children)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.String" />
        <Parameter Name="children" Type="AdaptiveExpressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Tipo de expressão de <see cref="T:AdaptiveExpressions.ExpressionType" /> .</param>
        <param name="children">Expressões filhas.</param>
        <summary>Crie uma expressão e valide-a.</summary>
        <returns>Nova expressão.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NotExpression">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression NotExpression (AdaptiveExpressions.Expression child);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression NotExpression(class AdaptiveExpressions.Expression child) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.NotExpression(AdaptiveExpressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NotExpression (child As Expression) As Expression" />
      <MemberSignature Language="F#" Value="static member NotExpression : AdaptiveExpressions.Expression -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.NotExpression child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="AdaptiveExpressions.Expression" />
      </Parameters>
      <Docs>
        <param name="child">Cláusulas filho.</param>
        <summary>Construir e validar uma expressão not.</summary>
        <returns>Nova expressão.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator AdaptiveExpressions.Expression (string expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class AdaptiveExpressions.Expression op_Implicit(string expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.op_Implicit(System.String)~AdaptiveExpressions.Expression" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (expression As String) As Expression" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.op_Implicit expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="expression">expressão de cadeia de caracteres.</param>
        <summary>permitir que uma cadeia de caracteres seja atribuída implicitamente a uma propriedade de expressão.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OrExpression">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression OrExpression (params AdaptiveExpressions.Expression[] children);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression OrExpression(class AdaptiveExpressions.Expression[] children) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.OrExpression(AdaptiveExpressions.Expression[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OrExpression (ParamArray children As Expression()) As Expression" />
      <MemberSignature Language="F#" Value="static member OrExpression : AdaptiveExpressions.Expression[] -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.OrExpression children" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="children" Type="AdaptiveExpressions.Expression[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.ParamArray]</AttributeName>
              <AttributeName Language="F#">[&lt;System.ParamArray&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="children">Cláusulas filho.</param>
        <summary>Construir e validar uma expressão or.</summary>
        <returns>Nova expressão.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression Parse (string expression, AdaptiveExpressions.EvaluatorLookup lookup = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression Parse(string expression, class AdaptiveExpressions.EvaluatorLookup lookup) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.Parse(System.String,AdaptiveExpressions.EvaluatorLookup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (expression As String, Optional lookup As EvaluatorLookup = Nothing) As Expression" />
      <MemberSignature Language="F#" Value="static member Parse : string * AdaptiveExpressions.EvaluatorLookup -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.Parse (expression, lookup)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.String" />
        <Parameter Name="lookup" Type="AdaptiveExpressions.EvaluatorLookup" />
      </Parameters>
      <Docs>
        <param name="expression">Cadeia de caracteres de expressão.</param>
        <param name="lookup">Pesquisa de função opcional ao analisar a expressão. O padrão é Expression. Lookup que usa a tabela Expression. Functions.</param>
        <summary>Analisar uma cadeia de caracteres de expressão em um objeto de expressão.</summary>
        <returns>objeto de expressão.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="References">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IReadOnlyList&lt;string&gt; References ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IReadOnlyList`1&lt;string&gt; References() cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.References" />
      <MemberSignature Language="VB.NET" Value="Public Function References () As IReadOnlyList(Of String)" />
      <MemberSignature Language="F#" Value="member this.References : unit -&gt; System.Collections.Generic.IReadOnlyList&lt;string&gt;" Usage="expression.References " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IReadOnlyList&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retornar os caminhos de referência estática para a memória.</summary>
        <returns>Lista dos caminhos de referência estática.</returns>
        <remarks>Retornar todos os caminhos estáticos para a memória.  Se houver um índice de elemento computado, o caminho será encerrado lá, mas você também poderá obter outros caminhos da parte computada.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceWalk">
      <MemberSignature Language="C#" Value="public (string,System.Collections.Generic.HashSet&lt;string&gt;) ReferenceWalk (AdaptiveExpressions.Expression expression, Func&lt;AdaptiveExpressions.Expression,bool&gt; extension = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ValueTuple`2&lt;string, class System.Collections.Generic.HashSet`1&lt;string&gt;&gt; ReferenceWalk(class AdaptiveExpressions.Expression expression, class System.Func`2&lt;class AdaptiveExpressions.Expression, bool&gt; extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.ReferenceWalk(AdaptiveExpressions.Expression,System.Func{AdaptiveExpressions.Expression,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Function ReferenceWalk (expression As Expression, Optional extension As Func(Of Expression, Boolean) = Nothing) As ValueTuple(Of String, HashSet(Of String))" />
      <MemberSignature Language="F#" Value="member this.ReferenceWalk : AdaptiveExpressions.Expression * Func&lt;AdaptiveExpressions.Expression, bool&gt; -&gt; ValueTuple&lt;string, System.Collections.Generic.HashSet&lt;string&gt;&gt;" Usage="expression.ReferenceWalk (expression, extension)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.String,System.Collections.Generic.HashSet&lt;System.String&gt;&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "path", "references" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "path", "references" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="AdaptiveExpressions.Expression" />
        <Parameter Name="extension" Type="System.Func&lt;AdaptiveExpressions.Expression,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <param name="expression">Expressão a ser analisada.</param>
        <param name="extension">Se presente, chamado para substituir a pesquisa por coisas como a expansão do modelo.</param>
        <summary>Percorrendo a função para identificar referências de memória estática em uma expressão.</summary>
        <returns>Caminho do acessador de expressão que é um caminho parcial potencial e o caminho completo encontrado até o momento.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public AdaptiveExpressions.ReturnType ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype AdaptiveExpressions.ReturnType ReturnType" />
      <MemberSignature Language="DocId" Value="P:AdaptiveExpressions.Expression.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReturnType As ReturnType" />
      <MemberSignature Language="F#" Value="member this.ReturnType : AdaptiveExpressions.ReturnType" Usage="AdaptiveExpressions.Expression.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.ReturnType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o resultado esperado da expressão de avaliação.</summary>
        <value>Resultado esperado da expressão de avaliação.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPathToValue">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression SetPathToValue (AdaptiveExpressions.Expression property, AdaptiveExpressions.Expression value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression SetPathToValue(class AdaptiveExpressions.Expression property, class AdaptiveExpressions.Expression value) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.SetPathToValue(AdaptiveExpressions.Expression,AdaptiveExpressions.Expression)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetPathToValue (property As Expression, value As Expression) As Expression" />
      <MemberSignature Language="F#" Value="static member SetPathToValue : AdaptiveExpressions.Expression * AdaptiveExpressions.Expression -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.SetPathToValue (property, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="AdaptiveExpressions.Expression" />
        <Parameter Name="value" Type="AdaptiveExpressions.Expression" />
      </Parameters>
      <Docs>
        <param name="property">expressão de propriedade.</param>
        <param name="value">expressão de valor.</param>
        <summary>Construir e validar um conjunto de uma expressão de propriedade para uma expressão de valor.</summary>
        <returns>Nova expressão.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetPathToValue">
      <MemberSignature Language="C#" Value="public static AdaptiveExpressions.Expression SetPathToValue (AdaptiveExpressions.Expression property, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class AdaptiveExpressions.Expression SetPathToValue(class AdaptiveExpressions.Expression property, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.SetPathToValue(AdaptiveExpressions.Expression,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetPathToValue (property As Expression, value As Object) As Expression" />
      <MemberSignature Language="F#" Value="static member SetPathToValue : AdaptiveExpressions.Expression * obj -&gt; AdaptiveExpressions.Expression" Usage="AdaptiveExpressions.Expression.SetPathToValue (property, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>AdaptiveExpressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="AdaptiveExpressions.Expression" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="property">expressão de propriedade.</param>
        <param name="value">objeto de valor.</param>
        <summary>Construir e validar um conjunto de uma expressão de propriedade para uma expressão de valor.</summary>
        <returns>Nova expressão.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="expression.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma cadeia de caracteres que representa o objeto atual.</summary>
        <returns>Um valor de cadeia de caracteres desta expressão.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryEvaluate">
      <MemberSignature Language="C#" Value="public (object,string) TryEvaluate (AdaptiveExpressions.Memory.IMemory state, AdaptiveExpressions.Options options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ValueTuple`2&lt;object, string&gt; TryEvaluate(class AdaptiveExpressions.Memory.IMemory state, class AdaptiveExpressions.Options options) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.TryEvaluate(AdaptiveExpressions.Memory.IMemory,AdaptiveExpressions.Options)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEvaluate (state As IMemory, Optional options As Options = Nothing) As ValueTuple(Of Object, String)" />
      <MemberSignature Language="F#" Value="member this.TryEvaluate : AdaptiveExpressions.Memory.IMemory * AdaptiveExpressions.Options -&gt; ValueTuple&lt;obj, string&gt;" Usage="expression.TryEvaluate (state, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.Object,System.String&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "value", "error" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "value", "error" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="AdaptiveExpressions.Memory.IMemory" />
        <Parameter Name="options" Type="AdaptiveExpressions.Options" />
      </Parameters>
      <Docs>
        <param name="state">Estado global para avaliar as expressões de acessadores.  Pode ser <see cref="T:System.Collections.Generic.IDictionary`2" /> , <see cref="T:System.Collections.IDictionary" /> caso contrário, a reflexão é usada para acessar a propriedade e o indexador.</param>
        <param name="options">Opções usadas na avaliação.</param>
        <summary>Avalie a expressão.</summary>
        <returns>Valor computado e uma cadeia de caracteres de erro.  Se a cadeia de caracteres não for nula, houve um erro de avaliação.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryEvaluate">
      <MemberSignature Language="C#" Value="public (object,string) TryEvaluate (object state, AdaptiveExpressions.Options options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ValueTuple`2&lt;object, string&gt; TryEvaluate(object state, class AdaptiveExpressions.Options options) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.TryEvaluate(System.Object,AdaptiveExpressions.Options)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEvaluate (state As Object, Optional options As Options = Nothing) As ValueTuple(Of Object, String)" />
      <MemberSignature Language="F#" Value="member this.TryEvaluate : obj * AdaptiveExpressions.Options -&gt; ValueTuple&lt;obj, string&gt;" Usage="expression.TryEvaluate (state, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.Object,System.String&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "value", "error" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "value", "error" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="options" Type="AdaptiveExpressions.Options" />
      </Parameters>
      <Docs>
        <param name="state">Estado global para avaliar as expressões de acessadores.  Pode ser <see cref="T:System.Collections.Generic.IDictionary`2" /> , <see cref="T:System.Collections.IDictionary" /> caso contrário, a reflexão é usada para acessar a propriedade e o indexador.</param>
        <param name="options">Opções usadas na avaliação.</param>
        <summary>Avalie a expressão.</summary>
        <returns>Valor computado e uma cadeia de caracteres de erro.  Se a cadeia de caracteres não for nula, houve um erro de avaliação.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryEvaluate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public (T,string) TryEvaluate&lt;T&gt; (AdaptiveExpressions.Memory.IMemory state, AdaptiveExpressions.Options options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ValueTuple`2&lt;!!T, string&gt; TryEvaluate&lt;T&gt;(class AdaptiveExpressions.Memory.IMemory state, class AdaptiveExpressions.Options options) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.TryEvaluate``1(AdaptiveExpressions.Memory.IMemory,AdaptiveExpressions.Options)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEvaluate(Of T) (state As IMemory, Optional options As Options = Nothing) As ValueTuple(Of T, String)" />
      <MemberSignature Language="F#" Value="member this.TryEvaluate : AdaptiveExpressions.Memory.IMemory * AdaptiveExpressions.Options -&gt; ValueTuple&lt;'T, string&gt;" Usage="expression.TryEvaluate (state, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;T,System.String&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "value", "error" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "value", "error" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="state" Type="AdaptiveExpressions.Memory.IMemory" />
        <Parameter Name="options" Type="AdaptiveExpressions.Options" />
      </Parameters>
      <Docs>
        <typeparam name="T">tipo de resultado da expressão.</typeparam>
        <param name="state">Estado global para avaliar as expressões de acessadores.  Pode ser <see cref="T:System.Collections.Generic.IDictionary`2" /> , <see cref="T:System.Collections.IDictionary" /> caso contrário, a reflexão é usada para acessar a propriedade e o indexador.</param>
        <param name="options">Opções usadas na avaliação.</param>
        <summary>Avalie a expressão.</summary>
        <returns>Valor computado e uma cadeia de caracteres de erro.  Se a cadeia de caracteres não for nula, houve um erro de avaliação.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryEvaluate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public (T,string) TryEvaluate&lt;T&gt; (object state, AdaptiveExpressions.Options options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ValueTuple`2&lt;!!T, string&gt; TryEvaluate&lt;T&gt;(object state, class AdaptiveExpressions.Options options) cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.TryEvaluate``1(System.Object,AdaptiveExpressions.Options)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryEvaluate(Of T) (state As Object, Optional options As Options = Nothing) As ValueTuple(Of T, String)" />
      <MemberSignature Language="F#" Value="member this.TryEvaluate : obj * AdaptiveExpressions.Options -&gt; ValueTuple&lt;'T, string&gt;" Usage="expression.TryEvaluate (state, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;T,System.String&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "value", "error" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "value", "error" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="options" Type="AdaptiveExpressions.Options" />
      </Parameters>
      <Docs>
        <typeparam name="T">tipo de resultado da expressão.</typeparam>
        <param name="state">Estado global para avaliar as expressões de acessadores.  Pode ser <see cref="T:System.Collections.Generic.IDictionary`2" /> , <see cref="T:System.Collections.IDictionary" /> caso contrário, a reflexão é usada para acessar a propriedade e o indexador.</param>
        <param name="options">Opções usadas na avaliação.</param>
        <summary>Avalie a expressão.</summary>
        <returns>Valor computado e uma cadeia de caracteres de erro.  Se a cadeia de caracteres não for nula, houve um erro de avaliação.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Type">
      <MemberSignature Language="C#" Value="public string Type { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Type" />
      <MemberSignature Language="DocId" Value="P:AdaptiveExpressions.Expression.Type" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Type As String" />
      <MemberSignature Language="F#" Value="member this.Type : string" Usage="AdaptiveExpressions.Expression.Type" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo de expressão.</summary>
        <value>Tipo de expressão.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public void Validate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Validate() cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.Validate" />
      <MemberSignature Language="VB.NET" Value="Public Sub Validate ()" />
      <MemberSignature Language="F#" Value="member this.Validate : unit -&gt; unit" Usage="expression.Validate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Validar expressão imediata.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateTree">
      <MemberSignature Language="C#" Value="public void ValidateTree ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ValidateTree() cil managed" />
      <MemberSignature Language="DocId" Value="M:AdaptiveExpressions.Expression.ValidateTree" />
      <MemberSignature Language="VB.NET" Value="Public Sub ValidateTree ()" />
      <MemberSignature Language="F#" Value="member this.ValidateTree : unit -&gt; unit" Usage="expression.ValidateTree " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>AdaptiveExpressions</AssemblyName>
        <AssemblyVersion>4.9.3.0</AssemblyVersion>
        <AssemblyVersion>4.10.0.0</AssemblyVersion>
        <AssemblyVersion>4.10.3.0</AssemblyVersion>
        <AssemblyVersion>4.11.0.0</AssemblyVersion>
        <AssemblyVersion>4.11.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Valide recursivamente a árvore de expressão.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
